---
title: "Many models"
output: html_notebook
---

本章介绍几种处理多个模型的方法：

* 如何综合运用多个简单模型解释复杂数据集；

* 使用列表特征（*list-column*）技术将任何数据存储在 data frame 中，例如用一列保存一个线性模型；

* 使用 *broom* 包将模型转换为 tidy data，从而使用各种数据处理技术分析 tidy data；

```{r}
library(modelr)
library(tidyverse)
```

# gapminder 数据集

```{r}
library(gapminder)
gapminder
```

为每个国家绘制一条 *年——预期寿命* 关系曲线：
```{r}
gapminder %>%
  ggplot(aes(year, lifeExp, group = country)) +
    geom_line(alpha = 1/3)
```

以新西兰为例，使用前面介绍的 *模型-残差* 的方法分析年代和预期寿命间的关系：
```{r}
nz <- filter(gapminder, country == "New Zealand")
nz %>%
  ggplot(aes(year, lifeExp)) +
  geom_line() +
  ggtitle("Full data = ")

nz_mod <- lm(lifeExp ~ year, data = nz)
nz %>%
  add_predictions(nz_mod) %>%
  ggplot(aes(year, pred)) +
  geom_line() +
  ggtitle("Linear trend + ")

nz %>%
  add_residuals(nz_mod) %>%
  ggplot(aes(year, resid)) +
  geom_hline(yintercept = 0, colour = "white", size = 3) +
  geom_line() +
  ggtitle("Remaining pattern")
```

效果不错，现在的问题是，如何为每个国家创建分析模型？

## 嵌套数据集 {#nesting}

为每个国家创建分析模型，需要从总体数据集中按 `country` 特征拆分出不同的子数据集，
`tidyr::nest` 函数是个合适的工具：
```{r}
by_country <- gapminder %>%
  group_by(country, continent) %>%
  nest()

by_country
```

新增加的特征 `data` 的每一行都是一个完整的 data frame（更准确地说是 tibble），
例如我们要查看亚洲国家阿富汗的数据：
```{r}
by_country$data[[1]]
```

所以 `nest()` 的作用是将一个每行是一个观测（一个国家在某一年份的预期寿命）的 data frame
转换成了每行是一个 data frame（某个国家在所有年份中的预期寿命）的 data frame。

## 列表特征

要为每个国家创建模型，首先将模型包装在一个函数里：
```{r}
country_model <- function(df) {
  lm(lifeExp ~ year, data = df)
}
```

然后用 `purrr::map()` 将函数应用到每个列表元素上：
```{r}
models <- map(by_country$data, country_model)
```

Data frame 最大的优点是能够将相关的信息放在一起，
如果能够将分析模型放到 `by_country` 中，就实现了将数据和模型整合到了一个 data frame里，
这正好可以通过 `dplyr::mutate` 函数实现：
```{r}
by_country <- by_country %>%
  mutate(model = map(data, country_model))
by_country
```

这里 `map` 函数的 `data` 参数表示 `by_country$data`。

这样就可以方便的对数据做筛选和排序了：
```{r}
by_country %>%
  filter(continent == "Europe")
by_country %>%
  arrange(continent, country)
```

## 展开数据集 {#unnesting}

为每个模型添加残差：
```{r}
by_country <- by_country %>%
  mutate(
    resids = map2(data, model, add_residuals)
  )
by_country
```

要绘制每个模型的残差图，首先将嵌套数据集展开成普通数据集：
```{r}
resids <- unnest(by_country, resids)
resids
```

为这个普通数据集绘制残差图：
```{r}
resids %>%
  ggplot(aes(year, resid)) +
    geom_line(aes(group = country), alpha = 1 / 3) +
    geom_smooth(se = FALSE)
```

按洲分组绘制残差图：
```{r}
resids %>%
  ggplot(aes(year, resid, group = country)) +
    geom_line(alpha = 1 / 3) +
    facet_wrap(~continent)
```

不难发现非洲的残差比较高，说明现有的线性模型并不能完美解释这个大洲的预期寿命变化趋势。

## 模型质量评估 {#model-quality}

```{r}
library(broom)
glance(nz_mod)
```

采用 `mutata() + unnest()` 可以将上面的方法扩展到整个数据集上：
```{r}
by_country %>%
  mutate(glance = map(model, broom::glance)) %>%
  unnest(glance)
```

去掉其中的列表特征列：
```{r}
glance <- by_country %>%
  mutate(glance = map(model, broom::glance)) %>%
  unnest(glance, .drop = TRUE)
glance
```

对所有模型按质量排序：
```{r}
glance %>%
  arrange(r.squared)
```

似乎所有模型质量差的国家都在非洲，用散点图验证一下：
```{r}
glance %>%
  ggplot(aes(continent, r.squared)) +
    geom_jitter(width = 0.3)
```

重点研究模型质量最差（$R^2 \lt 0.25$）的几个国家：
```{r}
bad_fit <- filter(glance, r.squared < 0.25)

gapminder %>%
  semi_join(bad_fit, by = "country") %>%
  ggplot(aes(year, lifeExp, colour = country)) +
    geom_line()
```

不难推测1994年卢旺达种族大屠杀和近几十年艾滋病肆虐可能是造成这些国家人口预期寿命反常下降的重要原因。

# 列表特征

R data frame 对 列表特征支持不够好：
```{r}
data.frame(x = list(1:3, 3:5))
```

通过 `I()` 可以实现列表特征，但打印效果不好：
```{r}
data.frame(
  x = I(list(1:3, 3:5)),
  y = c("1, 2", "3, 4, 5")
)
```

`tibble` 对列表特征的支持比较好，不会自动展开 list：
```{r}
tibble(
  x = list(1:3, 3:5),
  y = c("1, 2", "3, 4, 5")
)
```

或者使用 `tribble` 也能达到相同的效果：
```{r}
tribble(
   ~x, ~y,
  1:3, "1, 2",
  3:5, "3, 4, 5"
)
```

列表特征一般作为数据处理流程的中间结果，将相关的数据组织在一起，而不是作为 R 函数的直接处理对象。
基于列表特征的工作流程主要由以下3部分组成：

1. 创建包含列表特征的数据集：使用 `nest()`、`summarise() + list()` 或者 `mutate()` 加上一个 `map()` 函数，详见 [创建列表特征](#create-lc)；

1. 使用 `map()`、`map2()` 或者 `pmap()` 进一步转换这个数据集，参考 [模型质量评估](#model-quality) 中 `map()` 和 [展开数据集](#unnesting) 中的 `map2()` 函数；

1. 使用简化方法将包含列表特征的数据集还原为普通数据集，见 [简化列表特征](#simp-lc)。

# 创建列表特征 {#create-lc}

有3种方法创建列表特征列：

* `tidyr::nest()`:

* `mutata()`:

* `summarise`:

注意函数返回结果中，所有元素的类型应该是一致的，虽然数据集本身不会检查元素类型的一致性，
但为了后续使用映射函数不会出现异常，满足这一点是很有必要的。

## 使用 `nest()` 函数

`nest()` 可以通过两种方法生成特征列表，第一种是与 `group_by` 配合使用：
参考 [嵌套数据集](#nesting) 中的 `by_country`：
```{r}
by_country
```

它的元素包含出 `group_by` index 之外的所有特征：
```{r}
by_country$data[[1]]
```

第二种方法是单独使用，将需要嵌套的特征作为参数：
```{r}
nest2 <- gapminder %>%
  nest(year:gdpPercap)
nest2$data[[1]]
```

可以看到要得到相同的结果，`nest()` 参数与前面方法 `group_by()` 的参数应该是互补的。

## 使用向量函数

使用 `mutate()` 添加/修改特征时，如果返回的是一个向量（而非标量），就会生成向量特征：
```{r}
df <- tribble(
  ~x1,
  "a,b,c",
  "d,e,f,g"
)

df %>%
  mutate(x2 = stringr::str_split(x1, ","))
```

使用 `unnest()` 展开向量特征，注意展开的方向是竖向的，也就是保持特征數不变，增加观测数：
```{r}
df %>%
  mutate(x2 = stringr::str_split(x1, ",")) %>%
  unnest()
```

最后可是使用 `purrr::invoke_map()` 函数生成列表特征：
```{r}
sim <- tribble(
  ~f,      ~params,
  "runif", list(min = -1, max = 1),
  "rnorm", list(sd = 5),
  "rpois", list(lambda = 10)
)

sim %>%
  mutate(sims = invoke_map(f, params, n = 10))
```

注意 `sim$sims` 不完全是类型一致的，包含了实数向量和整数向量，
但由于实数运算完全覆盖整数运算，所以这样处理是合理的。



# 简化列表特征 {#simp-lc}

